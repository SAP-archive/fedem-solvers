// SPDX-FileCopyrightText: 2023 SAP SE
//
// SPDX-License-Identifier: Apache-2.0
//
// This file is part of FEDEM - https://openfedem.org
////////////////////////////////////////////////////////////////////////////////

/*!
  \file SignalHandler.C

  \brief Handling of various OS signals casing the program to abort.
*/

#include <iostream>

#include "SignalHandler.H"
#include "FFaLib/FFaCmdLineArg/FFaCmdLineArg.H"
#include <signal.h>


std::string SignalHandler::myProgName = "Fedem";

VoidFuncPtr SignalHandler::emergencyExit     = &SignalHandler::dummy;
VoidFuncPtr SignalHandler::emergencySaveExit = &SignalHandler::dummy;
VoidFuncPtr SignalHandler::killAllChilds     = &SignalHandler::dummy;


void SignalHandler::init(const char* program,
			 VoidFuncPtr f1, VoidFuncPtr f2, VoidFuncPtr f3)
{
  bool noSigHndl = false;
  FFaCmdLineArg::instance()->getValue ("noSignalHandling",noSigHndl);
  if (noSigHndl) return;

  myProgName = program;
  if (f1) emergencyExit = f1;

  if (f2)
    emergencySaveExit = f2;
  else if (f1)
    emergencySaveExit = f1;

  if (f3) killAllChilds = f3;

#ifndef FT_DEBUG // We do **not** handle signals when compiled in debug mode
  signal(SIGINT ,&processSignal); // User presses ctrl-C.
  signal(SIGILL ,&processSignal); // Illegal hardware instruction.
  signal(SIGABRT,&processSignal); // Generated by abort function.
  signal(SIGFPE ,&processSignal); // Division by 0, overflow, etc ...
  signal(SIGSEGV,&processSignal); // Segmentation violation.
  signal(SIGTERM,&processSignal); // Software termination.

#if !defined(win32) && !defined(win64)
  // Signals not supportend on Win32 platforms:
  signal(SIGQUIT,&processSignal); // User presses ctrl-\.
  signal(SIGBUS ,&processSignal); // Bus error.
#ifndef linux
  signal(SIGSYS, &processSignal); // Bad system call.
#endif
  signal(SIGPIPE,&processSignal); // Broken pipe.
  signal(SIGXCPU,&processSignal); // CPU time limit exceeded.
  signal(SIGXFSZ,&processSignal); // File size limit exceeded.
#endif
#endif
}


void SignalHandler::processSignal(int sig)
{
  enum {NONE, SAVE_AND_EXIT, EXIT, CLEAN_UP_CHILDREN} action;

  std::string strsig;
  switch (sig)
  {
    case SIGINT: // User presses ctrl-C.
      strsig = "SIGINT Interrupt";
      action = EXIT;
      break;

    case SIGILL: // Illegal hardware instruction.
      strsig = "SIGILL Illegal instruction";
      action = SAVE_AND_EXIT;
      break;

    case SIGABRT: // Generated by abort function.
      strsig = "SIGABRT Abort";
      action = SAVE_AND_EXIT;
      break;

    case SIGFPE: // Division by 0, overflow, etc...
      strsig = "SIGFPE Arithmetic exception";
      action = SAVE_AND_EXIT;
      break;

    case SIGSEGV: // Segmentation violation.
      strsig = "SIGSEGV Segmentation violation";
      action = SAVE_AND_EXIT;
      break;

    case SIGTERM: // Software termination sent by kill and system shutdown.
      strsig = "SIGTERM Software termination";
      action = EXIT;
      break;

#if !defined(win32) && !defined(win64)
    case SIGQUIT: // User presses ctrl-\.
      strsig = "SIGQUIT Quit";
      action = EXIT;
      break;

    case SIGBUS: // Bus error.
      strsig = "SIGBUS Bus error";
      action = SAVE_AND_EXIT;
      break;

#ifndef linux
    case SIGSYS: // Bad system call.
      strsig = "SIGSYS Bad system call";
      action = EXIT;
      break;
#endif

    case SIGPIPE: // Broken pipe.
      strsig = "SIGPIPE Broken pipe";
      action = CLEAN_UP_CHILDREN;
      break;

    case SIGXCPU: // CPU time limit exceeded.
      strsig = "SIGXCPU CPU time limit exceeded";
      action = SAVE_AND_EXIT;
      break;

    case SIGXFSZ: // File size limit exceeded.
      strsig = "SIGXFSZ File size limit exceeded";
      action = SAVE_AND_EXIT;
      break;
#endif

    default:
      action = NONE;
  }

  if (action != NONE)
    std::cout <<"\n *** "<< myProgName <<" recieved signal "<< strsig <<".\n";

  if (action == SAVE_AND_EXIT)
  {
    std::cout <<" *** "<< myProgName <<" trying emergency save and exit..."
              << std::endl;
    emergencySaveExit();
    exit(-1);
  }
  else if (action == EXIT)
  {
    std::cout <<" *** "<< myProgName <<" exiting..."<< std::endl;
    emergencyExit();
    exit(-1);
  }
  else if (action == CLEAN_UP_CHILDREN)
  {
    std::cout <<" *** "<< myProgName <<" cleaning up child processes (if any)."
              << std::endl;
    killAllChilds();
  }

  signal(sig,&processSignal); // Resetting signal handler
}
