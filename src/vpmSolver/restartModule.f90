!! SPDX-FileCopyrightText: 2023 SAP SE
!!
!! SPDX-License-Identifier: Apache-2.0
!!
!! This file is part of FEDEM - https://openfedem.org
!!==============================================================================

!> @file restartModule.f90
!> @brief Subroutines for restart handling.

!!==============================================================================
!> @brief Module with subroutines for simulation restart.
!>
!> @details This module contains the subroutines that handles restart of a
!> dynamics simulation. The state that is restarted from can either be read from
!> a set of frs-files generated by a previous simulation of the same model,
!> or provided through an in-core state array. The latter is typically used when
!> the solver is executed via the solver API by some external script.

module restartModule

  implicit none

  private

  !> @brief Initializes the mechanism configuration for restart.
  interface restartInit
     module procedure restartFromFile
     module procedure restartFromCore
  end interface

  public :: restartInit, getStateSize, saveToCore
  public :: getTransformationStateSize, saveTransformationDataToCore


contains

  !!============================================================================
  !> @brief Initializes the mechanism configuration from restart file.
  !>
  !> @param[in] sam Data for managing system matrix assembly
  !> @param sys System level model data
  !> @param mech Mechanism components of the model
  !> @param ctrl Control system data
  !> @param[in] lpu File unit number for res-file output
  !> @param[out] ierr Error flag
  !>
  !> @note Proper initialization of tire models is not implemented yet.
  !>
  !> @callgraph @callergraph
  !>
  !> @author Knut Morten Okstad
  !>
  !> @date 1 Nov 2005

  subroutine restartFromFile (sam, sys, mech, ctrl, lpu, ierr)

    use KindModule               , only : dp, i8, lfnam_p
    use SamModule                , only : SamType
    use SystemTypeModule         , only : SystemType, isQuasiStatic
    use MechanismTypeModule      , only : MechanismType
    use ControlTypeModule        , only : ControlType, hasControlElements
    use ControlRoutinesModule    , only : iterateControlSystem
    use MotionRoutinesModule     , only : updatePrescribedMotions
    use timeStepModule           , only : getInitialTimeStepSize
    use reportErrorModule        , only : reportError
    use reportErrorModule        , only : error_p, warning_p, debugFileOnly_p
    use progressModule           , only : writeProgress
    use FFaCmdLineArgInterface   , only : ffa_cmdlinearg_getdouble
    use FFaCmdLineArgInterface   , only : ffa_cmdlinearg_getstring
    use FFrExtractorInterface    , only : ffr_init, ffr_done, ffr_findData
    use FFrExtractorInterface    , only : ffr_setposition, ffr_increment
    use FiDeviceFunctionInterface, only : fidf_extFunc_ff

    type(SamType)      , intent(in)    :: sam
    type(SystemType)   , intent(inout) :: sys
    type(MechanismType), intent(inout) :: mech
    type(ControlType)  , intent(inout) :: ctrl
    integer            , intent(in)    :: lpu
    integer            , intent(out)   :: ierr

    !! Local variables
    character(lfnam_p) :: restartFile
    integer(i8)        :: gotStep
    real(dp)           :: gotTime, deltaT, restartTime

    !! --- Logic section ---

    !! Get restart time and restart file(s)
    call ffa_cmdlinearg_getdouble ('restarttime',restartTime)
    call ffa_cmdlinearg_getstring ('restartfile',restartFile)
    if (restartFile == '') then
       ierr = -1
       call reportError (error_p,'No restart frs-file(s) specified')
       goto 999
    end if

    !! Open frs-file(s) containing the response that we want to restart from
    call writeProgress (' --> Reading restart result file(s)')
    call ffr_init ('restartfile',ierr)
    if (ierr /= 0) then
       call reportError (error_p,'Error opening restart results database')
       goto 999
    end if

    !! Position frs-file at the time step from where we want to restart
    gotStep = -99_i8
    call ffr_setposition (restartTime,gotTime,gotStep)
    if (gotStep < 0_i8) then
       call reportError (error_p,'Error searching for restart results')
       ierr = -1
       goto 999
    end if

    if (gotStep < 1000000000_i8) then
       write(lpu,6000) gotStep, gotTime
    else
       write(lpu,6010) gotTime
    end if
    sys%nStep   = gotStep
    restartTime = gotTime

    !! Initiate the control system
    sys%time     = sys%tStart
    sys%timeStep = GetInitialTimeStepSize(sys,ierr)
    call IterateControlSystem (sys,ctrl,1,sam%mpar,ierr)
    if (ierr < 0) goto 999

    !! Initialize the external function values, if read from file
    call fidf_extFunc_ff (int(gotStep))

    !! Read current time step size
    call ffr_findData (sys%timeStep,1, &
         &             'Algorithm parameters|Time step size', &
         &             'Mechanism',mech%id%baseId,ierr)
    if (ierr /= 0) then
       call reportError (error_p,'Error reading current Time step size')
       goto 999
    end if

    !! Read current triad data
    call readTriadData (mech%triads,.false.,ierr)
    if (ierr /= 0) goto 999

    !! Read current superelement data
    call readSupData (mech%sups,.false.,ierr)
    if (ierr /= 0) goto 999

    !! Read current joint data
    call readJointData (mech%joints,.false.,ierr)
    if (ierr /= 0) goto 999

    !! Read current contact element data
    call readContactElementData (mech%cElems,ierr)
    if (ierr /= 0) goto 999

    if (.not. isQuasiStatic(sys,restartTime)) then

       if (hasControlElements(ctrl)) then
          !! Read current control variables
          call readControlData (ctrl,mech%id%baseId,ierr)
          if (ierr /= 0) goto 999

          ctrl%rreg(3) = 0.0_dp ! To enforce calculation of new Newton matrices
       end if

       !! Read system inertia force vector
       call ffr_findData (sys%FIactual(1),sam%neq,'Inertia forces', &
            &             'Mechanism',mech%id%baseId,ierr)
       if (ierr /= 0) then
          call DCOPY (sam%neq,0.0_dp,0,sys%FIactual(1),1)
          call reportError (warning_p,'System inertia forces not stored.', &
               'This may cause initial transients in a dynamics simulation.')
       end if

    end if

    !! Position file pointer at previous time step
    deltaT = sys%timeStep
    do while (gotStep >= sys%nStep)
       gotStep = -99_i8
       call ffr_setposition (gotTime-deltaT,gotTime,gotStep)
       deltaT = deltaT*2.0_dp
    end do
    do while (gotStep > 0_i8 .and. gotStep+1_i8 < sys%nStep)
       call ffr_increment (gotTime,gotStep)
    end do
    if (gotStep < 0_i8) then
       call reportError (error_p,'Error searching for restart results')
       ierr = -1
       goto 999
    else if (gotStep /= sys%nStep-1_i8) then
       call reportError (error_p, &
            'Can not restart the simulation at the requested time', &
            'because no results were stored for the previous time step')
       ierr = -1
       goto 999
    end if

    if (gotStep < 100000000_i8) then
       write(lpu,6001) gotStep, gotTime
    else
       write(lpu,6011) gotTime
    end if

    !! Read previous time step size
    call ffr_findData (sys%timePrev,1, &
         &             'Algorithm parameters|Time step size', &
         &             'Mechanism',mech%id%baseId,ierr)
    if (ierr /= 0) then
       call reportError (error_p,'Error reading previous Time step size')
       goto 999
    end if

    !! Read triad position for previous time step
    call readTriadData (mech%triads,.true.,ierr)
    if (ierr /= 0) goto 999

    !! Read superelement position for previous time step
    call readSupData (mech%sups,.true.,ierr)
    if (ierr /= 0) goto 999

    !! Read joint variables for previous time step
    call readJointData (mech%joints,.true.,ierr)
    if (ierr /= 0) goto 999

    call ffr_done ! Close the frs-file

    !! Evaluate the prescribed motions for previous time step
    sys%time = gotTime
    call updatePrescribedMotions (mech%motions,ierr)
    if (ierr /= 0) goto 999

    !! Evaluate the prescribed motions again at current time step
    !! and calculate the resulting constraint equation coefficients
    sys%time = restartTime
    call updatePrescribedMotions (sys%time,sys%timeStep,sys%beta,sys%gamma, &
         &                        sys%urd,sys%urdd,mech%motions,.false.,ierr)
    if (ierr /= 0) goto 999

    !! Initialize the system and mechanism model
    call restartInitialize (sam,sys,mech,ctrl,.false.,ierr)
    if (ierr == 0) return

999 call reportError (debugFileOnly_p,'restartInit')
    call ffr_done

6000 format(/5X,'Simulation is restarted from step',I10,' time =',1PE12.5)
6001 format( 5X,'using data from previous time step',I9,' time =',1PE12.5/)
6010 format(/5X,'Simulation is restarted from time',1PE12.5)
6011 format( 5X,'using data from previous time',1PE12.5/)

  end subroutine restartFromFile


  !!============================================================================
  !> @brief Reads triad results from results database for restart.
  !>
  !> @param triads All triads of the model
  !> @param[in] previousStep If .true., read into the previous configuration
  !> @param[out] ierr Error flag
  !>
  !> @callergraph
  !>
  !> @author Knut Morten Okstad
  !>
  !> @date 1 Nov 2005

  subroutine readTriadData (triads,previousStep,ierr)

    use TriadTypeModule  , only : TriadType
    use reportErrorModule, only : reportError, error_p, debugFileOnly_p

    type(TriadType), intent(inout) :: triads(:)
    logical        , intent(in)    :: previousStep
    integer        , intent(out)   :: ierr

    !! Local variables
    integer :: i, lerr

    !! --- Logic section ---

    ierr = 0
    do i = 1, size(triads)

       if (triads(i)%id%baseId < 0) then
          cycle ! This is a center of gravity triad for a generic part
       else if (previousStep) then
          if (triads(i)%nDOFs == 6) then
             call readVar ('Position matrix',triads(i)%id, &
                  &        triads(i)%urPrev(1,1),12)
          else if (triads(i)%nDOFs == 3) then
             call readVar ('Position',triads(i)%id, &
                  &        triads(i)%urPrev(1,4),3)
          end if
          cycle
       else
          if (triads(i)%nDOFs == 6) then
             call readVar ('Position matrix',triads(i)%id,triads(i)%ur(1,1),12)
          else if (triads(i)%nDOFs == 3) then
             call readVar ('Position',triads(i)%id,triads(i)%ur(1,4),3)
          else
             cycle
          end if
       end if

       call readVar ('Velocity',triads(i)%id,triads(i)%urd(1),3)
       call readVar ('Acceleration',triads(i)%id,triads(i)%urdd(1),3)
       if (associated(triads(i)%nodeForce)) then
          call readVar ('Total force',triads(i)%id,triads(i)%nodeForce(1),3)
       end if
       if (triads(i)%nDOFs == 6) then
          call readVar ('Angular velocity',triads(i)%id,triads(i)%urd(4),3)
          call readVar ('Angular acceleration',triads(i)%id,triads(i)%urdd(4),3)
          if (associated(triads(i)%nodeForce)) then
             call readVar ('Total moment',triads(i)%id,triads(i)%nodeForce(4),3)
          end if
       end if

    end do

    if (ierr < 0) call reportError (debugFileOnly_p,'readTriadData')

  contains

    !> @brief Reads a triad result quantity from the results database.
    subroutine readVar (chVar,triadId,triadData,nWords)
      use kindModule           , only : dp
      use IdTypeModule         , only : IdType, getId
      use FFrExtractorInterface, only : ffr_findData
      character(len=*), intent(in)  :: chVar
      type(IdType)    , intent(in)  :: triadId
      real(dp)        , intent(out) :: triadData
      integer         , intent(in)  :: nWords
      call ffr_findData (triadData,nWords,chVar,'Triad',triadId%baseId,lerr)
      if (lerr == 0) return
      ierr = ierr + lerr
      call reportError (error_p,'Failed to read '//chVar// &
           &                    ' for Triad'//getId(triadId))
    end subroutine readVar

  end subroutine readTriadData


  !!============================================================================
  !> @brief Reads superelement results from results database for restart.
  !>
  !> @param sups All superelements of the model
  !> @param[in] previousStep If .true., read into the previous configuration
  !> @param[out] ierr Error flag
  !>
  !> @callergraph
  !>
  !> @author Knut Morten Okstad
  !>
  !> @date 1 Nov 2005

  subroutine readSupData (sups,previousStep,ierr)

    use SupElTypeModule  , only : SupElType
    use reportErrorModule, only : reportError, error_p, debugFileOnly_p

    type(SupElType), intent(inout) :: sups(:)
    logical        , intent(in)    :: previousStep
    integer        , intent(out)   :: ierr

    !! Local variables
    integer           :: i, m, lerr
    character(len=23) :: chMode

    !! --- Logic section ---

    ierr = 0
    do i = 1, size(sups)

       if (sups(i)%nExtNods == 2 .and. sups(i)%rigidFlag < 0) then
          if (previousStep) then
             call readVar ('Position matrix',sups(i)%id, &
                  &        sups(i)%supTrPrev(1,1),12,'Beam')
          else
             call readVar ('Position matrix',sups(i)%id, &
                  &        sups(i)%supTr(1,1),12,'Beam')
          end if
       else
          if (previousStep) then
             call readVar ('Position matrix',sups(i)%id, &
                  &        sups(i)%supTrPrev(1,1),12)
          else
             call readVar ('Position matrix',sups(i)%id, &
                  &        sups(i)%supTr(1,1),12)
          end if
       end if

       if ( sups(i)%rigidFlag > 0 .and. &
            sups(i)%triads(1)%p%id%baseId < 0 .and. &
            sups(i)%triads(1)%p%nDOFs == 6 ) then

          !! This is a generic part with the CoG triad retained
          if (previousStep) then
             call readVar ('Center of Gravity Triad|Position matrix', &
                  &        sups(i)%id,sups(i)%triads(1)%p%urPrev(1,1),12)
          else
             call readVar ('Center of Gravity Triad|Position matrix', &
                  &        sups(i)%id,sups(i)%triads(1)%p%ur(1,1),12)
             call readVar ('Center of Gravity Triad|Velocity', &
                  &        sups(i)%id,sups(i)%triads(1)%p%urd(1),3)
             call readVar ('Center of Gravity Triad|Angular velocity', &
                  &        sups(i)%id,sups(i)%triads(1)%p%urd(4),3)
             call readVar ('Center of Gravity Triad|Acceleration', &
                  &        sups(i)%id,sups(i)%triads(1)%p%urdd(1),3)
             call readVar ('Center of Gravity Triad|Angular acceleration', &
                  &        sups(i)%id,sups(i)%triads(1)%p%urdd(4),3)
          end if

       else if (associated(sups(i)%genDOFs)) then

          !! This is a flexible FE part with component modes
          if (previousStep) then
             call readVar ('Generalized displacement',sups(i)%id, &
                  &        sups(i)%genDOFs%urPrev(1),size(sups(i)%genDOFs%ur))
          else
             call readVar ('Generalized displacement',sups(i)%id, &
                  &        sups(i)%genDOFs%ur(1),size(sups(i)%genDOFs%ur))
             do m = 1, size(sups(i)%genDOFs%urd)
                write(chMode,"('Component modes|Mode',I3)") m
                call readVar (chMode//'|Velocity',sups(i)%id, &
                     &        sups(i)%genDOFs%urd(m),1)
                call readVar (chMode//'|Acceleration',sups(i)%id, &
                     &        sups(i)%genDOFs%urdd(m),1)
             end do
          end if

       end if

    end do

    if (ierr < 0) call reportError (debugFileOnly_p,'readSupData')

  contains

    !> @brief Reads a superelement result quantity from the results database.
    subroutine readVar (chVar,supId,supData,nWords,typeName)
      use kindModule           , only : dp
      use IdTypeModule         , only : IdType, getId
      use FFrExtractorInterface, only : ffr_findData
      character(len=*), intent(in)  :: chVar
      type(IdType)    , intent(in)  :: supId
      real(dp)        , intent(out) :: supData
      integer         , intent(in)  :: nWords
      character(len=*), intent(in), optional :: typeName
      if (present(typeName)) then
         call ffr_findData (supData,nWords,chVar,typeName,supId%baseId,lerr)
      else
         call ffr_findData (supData,nWords,chVar,'Part',supId%baseId,lerr)
      end if
      if (lerr == 0) return
      ierr = ierr + lerr
      call reportError (error_p,'Failed to read '//chVar// &
           &                    ' for Part'//getId(supId))
    end subroutine readVar

  end subroutine readSupData


  !!============================================================================
  !> @brief Reads joint results from results database for restart.
  !>
  !> @param joints All joints of the model
  !> @param[in] previousStep If .true., read into the previous configuration
  !> @param[out] ierr Error flag
  !>
  !> @details The internal position matrices are then updated.
  !>
  !> @callgraph @callergraph
  !>
  !> @author Knut Morten Okstad
  !>
  !> @date 1 Nov 2005

  subroutine readJointData (joints,previousStep,ierr)

    use kindModule                , only : dp
    use MasterSlaveJointTypeModule, only : MasterSlaveJointType, jointTypeName_p
    use rotationModule            , only : vec_to_mat
    use reportErrorModule         , only : reportError, debugFileOnly_p

    type(MasterSlaveJointType), intent(inout) :: joints(:)
    logical                   , intent(in)    :: previousStep
    integer                   , intent(out)   :: ierr

    !! Local variables
    integer  :: i, j, lerr, lDof, iMat
    real(dp) :: jVar

    !! --- Logic section ---

    ierr = 0
    do i = 1, size(joints)
       do j = 1, size(joints(i)%jointDofs)
          if (joints(i)%jointDofs(j)%fixed) cycle

          call readJointDofData (jointTypeName_p(joints(i)%type), &
               &                 joints(i)%id,joints(i)%JointDofs(j), &
               &                 previousStep,lerr)
          ierr = ierr + lerr
          jVar = joints(i)%jointDofs(j)%jVar(1)
          lDof = joints(i)%jointDofs(j)%lDof
          iMat = joints(i)%jointDofs(j)%iMat
          if (lDof <= 3) then
             joints(i)%PosFromJVars(lDof,4,iMat) = jVar
          else if (lDof <= 6) then
             joints(i)%thetaVec(lDof-3,iMat)     = jVar
          end if

       end do
       do j = 1, joints(i)%nMats
          call vec_to_mat (joints(i)%thetaVec(:,j), &
               &           joints(i)%PosFromJVars(:,1:3,j))
       end do
    end do

    if (ierr /= 0) call reportError (debugFileOnly_p,'readJointData')

  end subroutine readJointData


  !!============================================================================
  !> @brief Reads joint DOF data for current time step.
  !>
  !> @param[in] jointType Type string of the joint in question
  !> @param[in] jointId ID of the joint in question
  !> @param jointDof The joint DOF to read response data for
  !> @param[in] previousStep If .true., read into the previous configuration
  !> @param[out] ierr Error flag
  !>
  !> @callgraph @callergraph
  !>
  !> @author Knut Morten Okstad
  !>
  !> @date 1 Nov 2005

  subroutine readJointDofData (jointType,jointId,jointDof,previousStep,ierr)

    use kindModule                , only : dp
    use MasterSlaveJointTypeModule, only : JointDofType
    use FrictionTypeModule        , only : UpdateAtConvergence
    use IdTypeModule              , only : IdType, getId
    use reportErrorModule         , only : reportError, error_p
    use FFrExtractorInterface     , only : ffr_findData

    character(len=*)  , intent(in)    :: jointType
    type(IdType)      , intent(in)    :: jointId
    type(JointDofType), intent(inout) :: jointDof
    logical           , intent(in)    :: previousStep
    integer           , intent(out)   :: ierr

    !! Local variables
    integer                     :: StickSlip
    real(dp)                    :: jointData(3)
    character(len=32)           :: varPath
    character(len=6), parameter :: dofSymbol_p(7) = (/ 'Tx    ', &
         &                                             'Ty    ', &
         &                                             'Tz    ', &
         &                                             'Rx    ', &
         &                                             'Ry    ', &
         &                                             'Rz    ', &
         &                                             'Slider' /)

    !! --- Logic section ---

    varPath = trim(dofSymbol_p(jointDof%lDof))//' joint variables'
    call ffr_findData (jointData(1),3,trim(varPath), &
         &             trim(jointType),jointId%baseId,ierr)
    if (ierr /= 0) goto 900

    if (previousStep) then
       jointDof%jVarPrev = jointData(1)
       return
    else
       jointDof%jVar = jointData
    end if

    if (associated(jointDof%friction)) then
       varPath(index(varPath,'j'):) = 'friction variables|pos'
       call ffr_findData (jointDof%friction%pos,1,trim(varPath), &
            &             trim(jointType),jointId%baseId,ierr)
       if (ierr /= 0) goto 900
       varPath(index(varPath,'|'):) = '|Stick/Slip'
       call ffr_findData (StickSlip,1,trim(varPath), &
            &             trim(jointType),jointId%baseId,ierr)
       if (ierr /= 0) goto 900

       jointDof%friction%lSlip(1) = StickSlip/10
       jointDof%friction%lSlip(2) = mod(StickSlip,10)

       call updateAtConvergence (jointDof%friction)
    end if

    return

900 call reportError (error_p,'Failed to read '//trim(varPath)// &
         &            ' for '//trim(jointType)//getId(jointId))

  end subroutine readJointDofData


  !!============================================================================
  !> @brief Reads contact element results from results database for restart.
  !>
  !> @param cElems All contact elements of the model
  !> @param[out] ierr Error flag
  !>
  !> @callergraph
  !>
  !> @author Knut Morten Okstad
  !>
  !> @date 14 Nov 2005

  subroutine readContactElementData (cElems,ierr)

    use ContactElementTypeModule, only : ContactElementType
    use reportErrorModule       , only : reportError, error_p, debugFileOnly_p

    type(ContactElementType), intent(inout) :: cElems(:)
    integer                 , intent(out)   :: ierr

    !! Local variables
    integer :: i, lerr

    !! --- Logic section ---

    ierr = 0
    do i = 1, size(cElems)

       call readVar ('Tx joint variables|Length', &
            &        cElems(i)%id,cElems(i)%cVarPrev(1))
       call readVar ('Ty joint variables|Length', &
            &        cElems(i)%id,cElems(i)%cVarPrev(2))
       call readVar ('Slider joint variables|Length', &
            &        cElems(i)%id,cElems(i)%cVarPrev(3))
       call readVar ('Accumulated contact distance', &
            &        cElems(i)%id,cElems(i)%accContactDist)

    end do

    if (ierr /= 0) call reportError (debugFileOnly_p,'readContactElementData')

  contains

    !> @brief Reads a contact element result quantity from the results database.
    subroutine readVar (chVar,cElmId,cElmVar)
      use kindModule           , only : dp
      use IdTypeModule         , only : IdType, getId
      use FFrExtractorInterface, only : ffr_findData
      character(len=*), intent(in)  :: chVar
      type(IdType)    , intent(in)  :: cElmId
      real(dp)        , intent(out) :: cElmVar
      call ffr_findData (cElmVar,1,chVar,'Cam joint',cElmId%baseId,lerr)
      if (lerr == 0) return
      ierr = ierr + lerr
      call reportError (error_p,'Failed to read '//chVar// &
           &                    ' for Contact element'//getId(cElmId))
    end subroutine readVar

  end subroutine readContactElementData


  !!============================================================================
  !> @brief Reads control system data from results database for restart.
  !>
  !> @param ctrl Control system data
  !> @param[in] mechId Base ID of the mechanism object of the model
  !> @param[out] ierr Error flag
  !>
  !> @callergraph
  !>
  !> @author Knut Morten Okstad
  !>
  !> @date 25 Nov 2008

  subroutine readControlData (ctrl,mechId,ierr)

    use ControlTypeModule    , only : ControlType
    use IdTypeModule         , only : getId, StrId
    use reportErrorModule    , only : reportError, error_p, debugFileOnly_p
    use FFrExtractorInterface, only : ffr_findData

    type(ControlType), intent(inout) :: ctrl
    integer          , intent(in)    :: mechId
    integer          , intent(out)   :: ierr

    !! Local variables
    integer :: i, lerr

    !! --- Logic section ---

    do i = 1, size(ctrl%vreg)
       call ffr_findData (ctrl%vreg(i),1,'Value', &
            &             'CtrlLine',ctrl%vregId(i)%baseId,lerr)
       if (lerr == 0) cycle

       ierr = ierr + lerr
       call reportError (error_p,'Failed to read value for Control Line'// &
            &            getId(ctrl%vregId(i)))
    end do

    call readIREG (1,ctrl%mpireg,'ICNT')
    !call readIREG (2,ctrl%mpireg,'MSTAT')
    !call readIREG (3,ctrl%mpireg,'MMOD')
    !call readIREG (4,ctrl%mpireg,'IPVT1')
    !call readIREG (5,ctrl%mpireg,'IPVT2')
    !call readIREG (6,ctrl%mpireg,'MPTOP')
    !call readIREG (7,ctrl%mpireg,'MPRPAR')
    !call readIREG (8,ctrl%mpireg,'MMTOP')
    call readRREG (1,ctrl%mprreg,'RCNT')
    call readRREG (2,ctrl%mprreg,'VPREG')
    !call readRREG (3,ctrl%mprreg,'VBREG')
    !call readRREG (4,ctrl%mprreg,'VLREG')
    !call readRREG (5,ctrl%mprreg,'VDREG')
    call readRREG (6,ctrl%mprreg,'VHREG')
    !call readRREG (7,ctrl%mprreg,'TOL')
    !call readRREG (8,ctrl%mprreg,'ERR')
    !call readRREG (9,ctrl%mprreg,'AJAC')
    !call readRREG(10,ctrl%mprreg,'ABE')
    !call readRREG(11,ctrl%mprreg,'ALO')
    !call readRREG(12,ctrl%mprreg,'RPAR')

    if (ctrl%ireg(10) > 0 .and. ierr == 0) then
       ierr = size(ctrl%delay) - ctrl%ireg(10)
       if (ierr < 0) then
          call reportError (error_p,'Can not restart with a reduced delay '// &
               'buffer size, old size ='//StrId(ctrl%ireg(10)), &
               'Specify a larger initial buffer size with option -delayBuffer')
          return
       end if

       call ffr_findData (ctrl%delay(1),ctrl%ireg(10),'DELAY', &
            &             'Mechanism',mechId,ierr)
       if (ierr < 0) call reportError (error_p,'Failed to read DELAY buffer')

       ctrl%ireg(10) = size(ctrl%delay) ! May restart with enlarged delay buffer
    end if
    if (ierr /= 0) call reportError (debugFileOnly_p,'readControlData')

  contains

    !> @brief Reads an integer array from the results database.
    subroutine readIREG (i,mp,name)
      integer         , intent(in) :: i, mp(:)
      character(len=*), intent(in) :: name
      call ffr_findData (ctrl%ireg(mp(i)),mp(i+1)-mp(i),name, &
           &             'Mechanism',mechId,lerr)
      if (lerr == 0) return
      ierr = ierr + lerr
      call reportError (error_p,'Failed to read Control system array '//name)
    end subroutine readIREG

    !> @brief Reads a real array from the results database.
    subroutine readRREG (i,mp,name)
      integer         , intent(in) :: i, mp(:)
      character(len=*), intent(in) :: name
      call ffr_findData (ctrl%rreg(mp(i)),mp(i+1)-mp(i),name, &
           &             'Mechanism',mechId,lerr)
      if (lerr == 0) return
      ierr = ierr + lerr
      call reportError (error_p,'Failed to read Control system array '//name)
    end subroutine readRREG

  end subroutine readControlData


  !!============================================================================
  !> @brief Calculates the length of the state array to restart from.
  !>
  !> @param[in] sam Data for managing system matrix assembly
  !> @param[in] mech Mechanism components of the model
  !> @param[in] ctrl Control system data
  !>
  !> @callergraph
  !>
  !> @author Knut Morten Okstad
  !>
  !> @date 13 Jan 2017

  function getStateSize (sam, mech, ctrl) result(ndat)

    use SamModule                , only : SamType
    use MechanismTypeModule      , only : MechanismType
    use ControlTypeModule        , only : ControlType, hasControlElements
    use FiDeviceFunctionInterface, only : fidf_extFuncSize

    type(SamType)      , intent(in) :: sam
    type(MechanismType), intent(in) :: mech
    type(ControlType)  , intent(in) :: ctrl

    !! Local variables
    integer :: i, j, ndat, ndof

    !! --- Logic section ---

    ndat = 6
    do i = 1, size(mech%triads)

       ndof = mech%triads(i)%nDOFs
       if (mech%triads(i)%id%baseId >= 0) then
          if (ndof == 6) then
             ndat = ndat + 24
          else if (ndof == 3) then
             ndat = ndat + 6
          else
             cycle
          end if
          if (associated(mech%triads(i)%nodeForce)) then
             ndat = ndat + 3*ndof
          else
             ndat = ndat + 2*ndof
          end if
       end if

    end do
    do i = 1, size(mech%sups)

       ndat = ndat + 24
       if ( mech%sups(i)%rigidFlag > 0 .and. &
            mech%sups(i)%triads(1)%p%id%baseId < 0 .and. &
            mech%sups(i)%triads(1)%p%nDOFs == 6 ) then
          ndat = ndat + 36
       else if (associated(mech%sups(i)%genDOFs)) then
          ndat = ndat + 4*size(mech%sups(i)%genDOFs%ur)
       end if

    end do
    do i = 1, size(mech%joints)

       do j = 1, size(mech%joints(i)%jointDofs)
          if (.not. mech%joints(i)%jointDofs(j)%fixed) then
             if (associated(mech%joints(i)%jointDofs(j)%friction)) then
                ndat = ndat + 6
             else
                ndat = ndat + 4
             end if
          end if
       end do

    end do
    do i = 1, size(mech%dampers)

       if (associated(mech%dampers(i)%dmp%spr)) ndat = ndat + 1

    end do

    ndat = ndat + 4*size(mech%cElems) + 2*size(mech%motions) + sam%neq

    if (hasControlElements(ctrl)) then

       ndat = ndat + size(ctrl%vreg) &
            + ctrl%mpireg(2)-ctrl%mpireg(1) &
            + ctrl%mprreg(3)-ctrl%mprreg(1) &
            + ctrl%mprreg(7)-ctrl%mprreg(6)
       if (associated(ctrl%delay)) ndat = ndat + ctrl%ireg(10)

    end if

    ndat = ndat + fidf_extFuncSize()

  end function getStateSize


  !!============================================================================
  !> @brief Calculates the length of the transformation state array.
  !>
  !> @param[in] mech Mechanism components of the model
  !>
  !> @callergraph
  !>
  !> @author Runar Heggelien Refsnaes
  !>
  !> @date 28 Jun 2017

  function getTransformationStateSize (mech) result(ndat)

    use MechanismTypeModule, only : MechanismType

    type(MechanismType), intent(in) :: mech

    !! Local variables
    integer :: i, ndat

    !! --- Logic section ---

    ndat = 3 + size(mech%sups)*14
    do i = 1, size(mech%triads)
       if (mech%triads(i)%id%baseId >= 0 .and. mech%triads(i)%nDOFs > 0) then
          ndat = ndat + 14
       end if
    end do

  end function getTransformationStateSize


  !!============================================================================
  !> @brief Initializes the mechanism configuration from provided state array.
  !>
  !> @param[in] sam Data for managing system matrix assembly
  !> @param sys System level model data
  !> @param mech Mechanism components of the model
  !> @param ctrl Control system data
  !> @param[in] ndat Length of the solution state array
  !> @param[in] data Solution state array
  !> @param[in] lpu File unit number for res-file output
  !> @param[out] istat Status flag, &lt;0: Error, &ge;0: Number of values read
  !>
  !> @callgraph @callergraph
  !>
  !> @author Knut Morten Okstad
  !>
  !> @date 13 Jan 2017

  subroutine restartFromCore (sam, sys, mech, ctrl, data, ndat, lpu, istat)

    use KindModule               , only : dp, i8
    use SamModule                , only : SamType
    use SystemTypeModule         , only : SystemType, isQuasiStatic
    use MechanismTypeModule      , only : MechanismType
    use ControlTypeModule        , only : ControlType, hasControlElements
    use ControlRoutinesModule    , only : iterateControlSystem
    use timeStepModule           , only : getInitialTimeStepSize
    use reportErrorModule        , only : reportError, error_p, debugFileOnly_p
    use progressModule           , only : writeProgress
    use FiDeviceFunctionInterface, only : fidf_extFunc_ff

    type(SamType)      , intent(in)    :: sam
    type(SystemType)   , intent(inout) :: sys
    type(MechanismType), intent(inout) :: mech
    type(ControlType)  , intent(inout) :: ctrl
    integer            , intent(in)    :: ndat
    real(dp)           , intent(in)    :: data(ndat)
    integer            , intent(in)    :: lpu
    integer            , intent(out)   :: istat

    !! Local variables
    integer(i8)       :: prevStep
    real(dp)          :: prevTime, restartTime
    character(len=64) :: msg

    !! --- Logic section ---

    call writeProgress (' --> Loading state to restart from')

    !! Initiate the control system
    sys%time     = sys%tStart
    sys%timeStep = GetInitialTimeStepSize(sys,istat)
    call IterateControlSystem (sys,ctrl,1,sam%mpar,istat)
    if (istat < 0) goto 915

    !! Extract current step number, time and time step size
    sys%nStep = nint(data(1),i8)
    restartTime = data(2)
    sys%timeStep = data(3)
    if (sys%nStep < 1000000000_i8) then
       write(lpu,6000) sys%nStep, restartTime
    else
       write(lpu,6010) restartTime
    end if
    istat = 4

    !! Extract current triad data
    call extractTriadData (mech%triads,data,ndat,istat)
    if (istat < 0) goto 915

    !! Extract current superelement data
    call extractSuperelementData (mech%sups,data,ndat,istat)
    if (istat < 0) goto 915

    !! Extract current joint data
    call extractJointData (mech%joints,data,ndat,istat)
    if (istat < 0) goto 915

    !! Extract current damper data
    call extractDamperData (mech%dampers,data,ndat,istat)
    if (istat < 0) goto 915

    !! Extract current contact element data
    call extractContactElementData (mech%cElems,data,ndat,istat)
    if (istat < 0) goto 915

    !! Extract current prescribed motion data
    call extractMotionData (mech%motions,data,ndat,istat)
    if (istat < 0) goto 915

    if (hasControlElements(ctrl)) then
       !! Extract current control variables
       call extractControlData (ctrl,data,ndat,istat)
       if (istat < 0) goto 915

       ctrl%rreg(3) = 0.0_dp ! To enforce calculation of new Newton matrices
    end if

    !! Initialize the external function values, if read from file
    call fidf_extFunc_ff (int(sys%nStep))

    !! Extract external function values from state array, if any
    call fidf_storeExtFunc (data,ndat,2,istat)
    if (istat < 0) goto 915

    !! Extract system inertia force vector
    if (isQuasiStatic(sys,restartTime)) then
       call DCOPY (sam%neq,0.0_dp,0,sys%FIactual(1),1)
    else
       call DCOPY (sam%neq,data(istat),1,sys%FIactual(1),1)
    end if
    istat = istat + sam%neq
    if (istat > ndat+1) then
       istat = ndat+1 - istat
       call reportError (error_p,'State array exhausted while loading '// &
            &            'System inertia vector')
       goto 915
    end if

    !! Extract previous step, time and time step size
    prevStep = nint(data(istat),i8)
    prevTime = data(istat+1)
    sys%timePrev = data(istat+2)
    if (prevStep < 100000000_i8) then
       write(lpu,6001) prevStep, prevTime
    else
       write(lpu,6011) prevTime
    end if
    istat = istat + 3

    !! Check data consistency
    if (istat /= ndat+1) then
       write(msg,6020) istat-1,ndat
       call reportError (error_p,'Invalid state vector to restart from',msg)
       istat = -abs(ndat+1 - istat)
    else if (sys%nStep < 2_i8 .or. prevStep /= sys%nStep-1_i8 .or. &
         &   prevTime >= restartTime) then
       call reportError (error_p,'Invalid state to restart from')
       istat = -999
    else
       !! Initialize the system and mechanism model
       sys%time = restartTime
       call restartInitialize (sam,sys,mech,ctrl,.true.,istat)
       if (istat == 0) return
    end if

915 call reportError (debugFileOnly_p,'restartInit')

6000 format(/5X,'Simulation is restarted from step',I10,' time =',1PE12.5)
6001 format( 5X,'using data from previous time step',I9,' time =',1PE12.5/)
6010 format(/5X,'Simulation is restarted from time',1PE12.5)
6011 format( 5X,'using data from previous time',1PE12.5/)
6020 format('Expected length:',I8,5X,'Actual length:',I8)

  end subroutine restartFromCore


  !!============================================================================
  !> @brief Extracts triad results from in-core array for restart.
  !>
  !> @param triads All triads in the model
  !> @param[in] ndat Length of the solution state array
  !> @param[in] data Solution state array
  !> @param idat Running array index, &lt;0: Error, &ge;0: Number of values read
  !>
  !> @callergraph
  !>
  !> @author Knut Morten Okstad
  !>
  !> @date 13 Jan 2017

  subroutine extractTriadData (triads,data,ndat,idat)

    use TriadTypeModule, only : TriadType, dp

    type(TriadType), intent(inout) :: triads(:)
    integer        , intent(in)    :: ndat
    real(dp)       , intent(in)    :: data(ndat)
    integer        , intent(inout) :: idat

    !! Local variables
    integer :: i, ndof

    !! --- Logic section ---

    do i = 1, size(triads)

       ndof = triads(i)%nDOFs
       if (triads(i)%id%baseId < 0) then
          cycle ! This is a center of gravity triad for a generic part
       else if (ndof == 6) then
          triads(i)%urPrev = reshape(data(idat:idat+11),(/3,4/))
          triads(i)%ur = reshape(data(idat+12:idat+23),(/3,4/))
          idat = idat + 24
       else if (ndof == 3) then
          triads(i)%urPrev(:,4) = data(idat:idat+2)
          triads(i)%ur(:,4) = data(idat+3:idat+5)
          idat = idat + 6
       else
          cycle
       end if

       triads(i)%urd = data(idat:idat+ndof-1); idat = idat + ndof
       triads(i)%urdd = data(idat:idat+ndof-1); idat = idat + ndof
       if (associated(triads(i)%nodeForce)) then
          triads(i)%nodeForce = data(idat:idat+ndof-1); idat = idat + ndof
       end if

       if (outOfRange('extract','Triad',triads(i)%id,idat,ndat)) return

    end do

  end subroutine extractTriadData


  !!============================================================================
  !> @brief Extracts superelement results from in-core array for restart.
  !>
  !> @param sups All superelements in the model
  !> @param[in] ndat Length of the solution state array
  !> @param[in] data Solution state array
  !> @param idat Running array index, &lt;0: Error, &ge;0: Number of values read
  !>
  !> @callergraph
  !>
  !> @author Knut Morten Okstad
  !>
  !> @date 13 Jan 2017

  subroutine extractSuperelementData (sups,data,ndat,idat)

    use SupElTypeModule, only : SupElType, dp

    type(SupElType), intent(inout) :: sups(:)
    integer        , intent(in)    :: ndat
    real(dp)       , intent(in)    :: data(ndat)
    integer        , intent(inout) :: idat

    !! Local variables
    integer :: i, ndof

    !! --- Logic section ---

    do i = 1, size(sups)

       sups(i)%supTrPrev = reshape(data(idat:idat+11),(/3,4/))
       sups(i)%supTr = reshape(data(idat+12:idat+23),(/3,4/))
       idat = idat + 24

       if ( sups(i)%rigidFlag > 0 .and. &
            sups(i)%triads(1)%p%id%baseId < 0 .and. &
            sups(i)%triads(1)%p%nDOFs == 6 ) then

          !! This is a generic part with the CoG triad retained
          sups(i)%triads(1)%p%urPrev = reshape(data(idat:idat+11),(/3,4/))
          sups(i)%triads(1)%p%ur     = reshape(data(idat+12:idat+23),(/3,4/))
          sups(i)%triads(1)%p%urd    = data(idat+24:idat+29)
          sups(i)%triads(1)%p%urdd   = data(idat+30:idat+35)
          idat = idat + 36

       else if (associated(sups(i)%genDOFs)) then

          !! This is a flexible FE part with component modes
          ndof = size(sups(i)%genDOFs%ur)
          sups(i)%genDOFs%urPrev = data(idat:idat+ndof-1); idat = idat + ndof
          sups(i)%genDOFs%ur     = data(idat:idat+ndof-1); idat = idat + ndof
          sups(i)%genDOFs%urd    = data(idat:idat+ndof-1); idat = idat + ndof
          sups(i)%genDOFs%urdd   = data(idat:idat+ndof-1); idat = idat + ndof

       end if

       if (outOfRange('extract','Superelement',sups(i)%id,idat,ndat)) return

    end do

  end subroutine extractSuperelementData


  !!============================================================================
  !> @brief Extracts joint results from in-core state array for restart.
  !>
  !> @param joints All joints in the model
  !> @param[in] ndat Length of the solution state array
  !> @param[in] data Solution state array
  !> @param idat Running array index, &lt;0: Error, &ge;0: Number of values read
  !>
  !> @details The internal position matrices are then updated.
  !>
  !> @callergraph
  !>
  !> @author Knut Morten Okstad
  !>
  !> @date 13 Jan 2017

  subroutine extractJointData (joints,data,ndat,idat)

    use MasterSlaveJointTypeModule, only : MasterSlaveJointType, dp
    use rotationModule            , only : vec_to_mat

    type(MasterSlaveJointType), intent(inout) :: joints(:)
    integer                   , intent(in)    :: ndat
    real(dp)                  , intent(in)    :: data(ndat)
    integer                   , intent(inout) :: idat

    !! Local variables
    integer  :: i, j, lDof, iMat
    real(dp) :: jVar

    !! --- Logic section ---

    do i = 1, size(joints)
       do j = 1, size(joints(i)%jointDofs)
          if (joints(i)%jointDofs(j)%fixed) cycle

          call extractJDof (joints(i)%jointDofs(j),idat)
          if (outOfRange('extract','Joint',joints(i)%id,idat,ndat)) return

          jVar = joints(i)%jointDofs(j)%jVar(1)
          lDof = joints(i)%jointDofs(j)%lDof
          iMat = joints(i)%jointDofs(j)%iMat
          if (lDof <= 3) then
             joints(i)%PosFromJVars(lDof,4,iMat) = jVar
          else if (lDof <= 6) then
             joints(i)%thetaVec(lDof-3,iMat)     = jVar
          end if

       end do
       do j = 1, joints(i)%nMats
          call vec_to_mat (joints(i)%thetaVec(:,j), &
               &           joints(i)%PosFromJVars(:,1:3,j))
       end do
    end do

  contains

    !> @brief Extracts joint DOF results from the in-core state array.
    subroutine extractJDof (jDof,idat)
      use MasterSlaveJointTypeModule, only : JointDofType
      use FrictionTypeModule        , only : updateAtConvergence
      type(JointDofType), intent(inout) :: jDof
      integer           , intent(inout) :: idat
      integer                           :: StickSlip
      jDof%jVarPrev = data(idat)
      jDof%jVar = data(idat+1:idat+3)
      idat = idat + 4
      if (associated(jDof%friction)) then
         jDof%friction%pos = data(idat)
         StickSlip = nint(data(idat+1))
         idat = idat + 2
         jDof%friction%lSlip(1) = StickSlip/10
         jDof%friction%lSlip(2) = mod(StickSlip,10)
         call updateAtConvergence (jDof%friction)
      end if
    end subroutine extractJDof

  end subroutine extractJointData


  !!============================================================================
  !> @brief Extracts damper results from state array for restart.
  !>
  !> @param dampers All damper elements in the model
  !> @param[in] ndat Length of the solution state array
  !> @param[in] data Solution state array
  !> @param idat Running array index, &lt;0: Error, &ge;0: Number of values read
  !>
  !> @details Only the damper velocity is extracted, and only if the damper uses
  !> deformational velocity. Because it is computed using the previous spring
  !> deflection which is not known at restart point.
  !>
  !> @callergraph
  !>
  !> @author Knut Morten Okstad
  !>
  !> @date 1 Jul 2022

  subroutine extractDamperData (dampers,data,ndat,idat)

    use DamperTypeModule, only : DamperType, dp

    type(DamperType), intent(inout) :: dampers(:)
    integer         , intent(in)    :: ndat
    real(dp)        , intent(in)    :: data(ndat)
    integer         , intent(inout) :: idat

    !! Local variables
    integer :: i

    !! --- Logic section ---

    do i = 1, size(dampers)
       if (associated(dampers(i)%dmp%spr)) then

          dampers(i)%dmp%velocity = data(idat)
          idat = idat + 1

          if (outOfRange('extract','Damper',dampers(i)%dmp%id,idat,ndat)) return

       end if
    end do

  end subroutine extractDamperData


  !!============================================================================
  !> @brief Extracts contact element results from state array for restart.
  !>
  !> @param cElems All contact elements in the model
  !> @param[in] ndat Length of the solution state array
  !> @param[in] data Solution state array
  !> @param idat Running array index, &lt;0: Error, &ge;0: Number of values read
  !>
  !> @callergraph
  !>
  !> @author Knut Morten Okstad
  !>
  !> @date 13 Jan 2017

  subroutine extractContactElementData (cElems,data,ndat,idat)

    use ContactElementTypeModule, only : ContactElementType, dp

    type(ContactElementType), intent(inout) :: cElems(:)
    integer                 , intent(in)    :: ndat
    real(dp)                , intent(in)    :: data(ndat)
    integer                 , intent(inout) :: idat

    !! Local variables
    integer :: i

    !! --- Logic section ---

    do i = 1, size(cElems)

       cElems(i)%cVarPrev = data(idat:idat+2)
       cElems(i)%accContactDist = data(idat+3)
       idat = idat + 4

       if (outOfRange('extract','Contactelement',cElems(i)%id,idat,ndat)) return

    end do

  end subroutine extractContactElementData


  !!============================================================================
  !> @brief Extracts prescribed motion results from state array for restart.
  !>
  !> @param[in] motions All prescribed motions in the model
  !> @param[in] ndat Length of the solution state array
  !> @param[in] data Solution state array
  !> @param idat Running array index, &lt;0: Error, &ge;0: Number of values read
  !>
  !> @callergraph
  !>
  !> @author Knut Morten Okstad
  !>
  !> @date 13 Jan 2017

  subroutine extractMotionData (motions,data,ndat,idat)

    use MotionTypeModule, only : MotionType, dp

    type(MotionType), intent(inout) :: motions(:)
    integer         , intent(in)    :: ndat
    real(dp)        , intent(in)    :: data(ndat)
    integer         , intent(inout) :: idat

    !! Local variables
    integer :: i

    !! --- Logic section ---

    do i = 1, size(motions)

       motions(i)%D = data(idat)
       motions(i)%cc = data(idat+1)
       idat = idat + 2

       if (outOfRange('extract','Motion',motions(i)%id,idat,ndat)) return

    end do

  end subroutine extractMotionData


  !!============================================================================
  !> @brief Extracts control system data from state array for restart.
  !>
  !> @param ctrl Control system data
  !> @param[in] ndat Length of the solution state array
  !> @param[in] data Solution state array
  !> @param idat Running array index, &lt;0: Error, &ge;0: Number of values read
  !>
  !> @callergraph
  !>
  !> @author Knut Morten Okstad
  !>
  !> @date 22 Dec 2020

  subroutine extractControlData (ctrl,data,ndat,idat)

    use KindModule       , only : dp
    use ControlTypeModule, only : ControlType
    use IdTypeModule     , only : StrId
    use reportErrorModule, only : reportError, error_p

    type(ControlType), intent(inout) :: ctrl
    integer          , intent(in)    :: ndat
    real(dp)         , intent(in)    :: data(ndat)
    integer          , intent(inout) :: idat

    !! Local variables
    integer :: ip, nw

    !! --- Logic section ---

    nw = size(ctrl%vreg)
    call DCOPY (nw,data(idat),1,ctrl%vreg(1),1)
    idat = idat + nw

    !! Extract integer control array ICNT
    do ip = ctrl%mpireg(1), ctrl%mpireg(2)-1
       ctrl%ireg(ip) = int(data(idat))
       idat = idat + 1
    end do

    call extractRREG (1) ! Extract real control array RCNT
    call extractRREG (2) ! Extract real control array VPREG
    call extractRREG (6) ! Extract real control array VHREG

    nw = ctrl%ireg(10)
    if (nw > 0 .and. idat+nw-1 <= ndat) then
       if (size(ctrl%delay) < nw) then
          call reportError (error_p,'Can not restart with a reduced delay '// &
               'buffer size, old size ='//StrId(ctrl%ireg(10)), &
               'Specify a larger initial buffer size with option -delayBuffer',&
               addString='extractControlData')
          idat = size(ctrl%delay) - nw
          return
       end if
       call DCOPY (nw,data(idat),1,ctrl%delay(1),1)
       idat = idat + nw
       ctrl%ireg(10) = size(ctrl%delay) ! May restart with enlarged delay buffer
    end if

    if (idat <= ndat+1) return

    idat = ndat+1 - idat
    call reportError (error_p,'State array exhausted while loading '// &
         &            'control system data',addString='extractControlData')

  contains

    !> @brief Extracts a control array from the state array.
    subroutine extractRREG (i)
      integer, intent(in) :: i
      ip = ctrl%mprreg(i)
      nw = ctrl%mprreg(i+1) - ip
      call DCOPY (nw,data(idat),1,ctrl%rreg(ip),1)
      idat = idat + nw
    end subroutine extractRREG

  end subroutine extractControlData


  !!============================================================================
  !> @brief Initializes the mechanism configuration for restart.
  !>
  !> @param[in] sam Data for managing system matrix assembly
  !> @param sys System level model data
  !> @param mech Mechanism components of the model
  !> @param[in] ctrl Control system data
  !> @param[in] fromCore If .true., invoked from restartmodule::restartfromcore
  !> @param[out] ierr Error flag
  !>
  !> @callgraph @callergraph
  !>
  !> @author Knut Morten Okstad
  !>
  !> @date 13 Jan 2017

  subroutine restartInitialize (sam, sys, mech, ctrl, fromCore, ierr)

    use SamModule                     , only : SamType, dp
    use SystemTypeModule              , only : SystemType, isQuasiStatic
    use MechanismTypeModule           , only : MechanismType
    use ControlTypeModule             , only : ControlType
    use HydroDynamicsModule           , only : initiateHydroDynBodies
    use BushingElementRoutinesModule  , only : updateBushingElements
    use ContactElementRoutinesModule  , only : updateContactElements
    use MasterSlaveJointRoutinesModule, only : updateJoints
    use SpringRoutinesModule          , only : updateSprings, updateSpringYields
    use DamperRoutinesModule          , only : updateDampers
    use ForceRoutinesModule           , only : updateExternalForces
    use MassRoutinesModule            , only : updateMasses
    use WindTurbineRoutinesModule     , only : updateAeroForces
    use SolverRoutinesModule          , only : clearVelAcc, dumpStep
    use TriadTypeModule               , only : GetTriadsVelAcc
    use SupElTypeModule               , only : GetSupElsVelAcc, buildFinit
    use MasterSlaveJointTypeModule    , only : GetJointsVelAcc
    use profilerModule                , only : startTimer, stopTimer, ini_p
    use reportErrorModule             , only : reportError, debugFileOnly_p
    use FFaCmdLineArgInterface        , only : ffa_cmdlinearg_intValue

    type(SamType)      , intent(in)    :: sam
    type(SystemType)   , intent(inout) :: sys
    type(MechanismType), intent(inout) :: mech
    type(ControlType)  , intent(in)    :: ctrl
    logical            , intent(in)    :: fromCore
    integer            , intent(out)   :: ierr

    !! Local variables
    integer :: i, ndof

    !! --- Logic section ---

    !! Update all mechanism objects

    do i = 1, size(mech%sups)
       ndof = size(mech%sups(i)%finit)
       call buildFinit (mech%sups(i))
       call DCOPY (ndof,mech%sups(i)%finit(1),1,mech%sups(i)%finitPrev(1),1)
    end do
    call initiateHydroDynBodies (mech%sups,mech%elms,mech%env,.true.,ierr)
    call updateJoints (mech%joints,mech%motions,ierr)
    call updateSpringYields (mech%springYields,ierr)
    call updateSprings (mech%axialSprings,mech%joints,.true.,ierr)
    do i = 1, size(mech%baseSprings)
       mech%baseSprings(i)%forcePrev = mech%baseSprings(i)%force
       mech%baseSprings(i)%lengthPrev = mech%baseSprings(i)%length
       mech%baseSprings(i)%deflectionPrev = mech%baseSprings(i)%deflection
    end do
    if (fromCore) then ! deformational velocity is restored from state array
       call updateDampers (mech%dampers,0.0_dp,.true.,ierr)
    else ! deformational velocity will be initialized to zero
       call updateDampers (mech%dampers,sys%timeStep,.true.,ierr)
    end if
    do i = 1, size(mech%baseDampers)
       mech%baseDampers(i)%forcePrev = mech%baseDampers(i)%force
       mech%baseDampers(i)%lengthPrev = mech%baseDampers(i)%length
    end do
    call updateBushingElements (mech%bElems,ierr)
    call updateContactElements (mech%cElems,sys%timeStep,ierr)
    call updateExternalForces (mech%forces,-1,ierr)
    call updateMasses (mech%masses,mech%gravity,.true.,ierr)

    if (associated(mech%turbine)) then
       !! Calculate loads on wind turbine blades for the start configuration
       call stopTimer (ini_p) ! We are currently measuring initialization time
       call updateAeroForces (sys%time,mech%turbine,ierr)
       call startTimer (ini_p) ! Restart the initialization timer again
       if (ierr /= 0) goto 915
    end if

    if (isQuasiStatic(sys)) then
       !! Zero out velocities and accelerations such that a future switch
       !! to dynamics simulation will start from a resting state
       call clearVelAcc (mech%triads,mech%joints,.false.)
       call DCOPY (sam%ndof,0.0_dp,0,sys%urd(1),1)
       call DCOPY (sam%ndof,0.0_dp,0,sys%urdd(1),1)
    else
       !! Load component velocities and accelerations into system vectors
       call GetTriadsVelAcc (mech%triads,sys%urd,sys%urdd)
       call GetSupElsVelAcc (mech%sups  ,sys%urd,sys%urdd)
       call GetJointsVelAcc (mech%joints,sys%urd,sys%urdd)
    end if

    if (ffa_cmdlinearg_intValue('debug') > 0) then
       call dumpStep (sys,mech,ctrl,sam,fName='datastructure.rst')
    end if

    return

915 call reportError (debugFileOnly_p,'restartInitialize')

  end subroutine restartInitialize


  !!============================================================================
  !> @brief Saves state-dependent data of current time step to an array in core.
  !>
  !> @param[in] sam Data for managing system matrix assembly
  !> @param[in] sys System level model data
  !> @param[in] mech Mechanism components of the model
  !> @param[in] ctrl Control system data
  !> @param[in] ndat Length of the solution state array
  !> @param[in] data Solution state array
  !> @param[out] istat Status flag, &lt;0: Error, =0: Ok,
  !> &gt;0: The @a data array is this value longer than necessary
  !>
  !> @details Currently does not tires, aerodynamics, etc.
  !>
  !> @callgraph @callergraph
  !>
  !> @author Knut Morten Okstad
  !>
  !> @date 16 Jan 2017

  subroutine saveToCore (sam, sys, mech, ctrl, data, ndat, istat)

    use KindModule               , only : dp, i8
    use SamModule                , only : SamType
    use SystemTypeModule         , only : SystemType
    use MechanismTypeModule      , only : MechanismType
    use ControlTypeModule        , only : ControlType, hasControlElements
    use reportErrorModule        , only : reportError, error_p, note_p
    use reportErrorModule        , only : debugFileOnly_p
    use progressModule           , only : writeProgress
    use FiDeviceFunctionInterface, only : fidf_storeExtFunc
    use FFaCmdLineArgInterface   , only : ffa_cmdlinearg_intValue

    type(SamType)      , intent(in)  :: sam
    type(SystemType)   , intent(in)  :: sys
    type(MechanismType), intent(in)  :: mech
    type(ControlType)  , intent(in)  :: ctrl
    integer            , intent(in)  :: ndat
    real(dp)           , intent(out) :: data(ndat)
    integer            , intent(out) :: istat

    !! --- Logic section ---

    if (ndat < 3) then
       istat = 0
       call reportError (note_p,'No state array provided, saving skipped')
       return
    end if

    call writeProgress (' --> Saving current state to core')

    !! Save current step number, time and time step size
    data(1) = real(sys%nStep,dp)
    data(2) = sys%time
    data(3) = sys%timeStep
    istat = 4

    !! Save current triad data
    call saveTriadData (mech%triads,data,ndat,istat)
    if (istat < 0) goto 915

    !! Save current superelement data
    call saveSuperelementData (mech%sups,data,ndat,istat)
    if (istat < 0) goto 915

    !! Save current joint data
    call saveJointData (mech%joints,data,ndat,istat)
    if (istat < 0) goto 915

    !! Save current damper data
    call saveDamperData (mech%dampers,data,ndat,istat)
    if (istat < 0) goto 915

    !! Save current contact element data
    call saveContactElementData (mech%cElems,data,ndat,istat)
    if (istat < 0) goto 915

    !! Save current prescribed motion data
    call saveMotionData (mech%motions,data,ndat,istat)
    if (istat < 0) goto 915

    !! Save control system data, if any
    if (hasControlElements(ctrl)) then
       call saveControlData (ctrl,data,ndat,istat)
       if (istat < 0) goto 915
    end if

    !! Save external function values, if any
    call fidf_storeExtFunc (data,ndat,1,istat)
    if (istat < 0) goto 915

    !! Save the system inertia force vector
    if (mod(ffa_cmdlinearg_intValue('NewmarkFlag'),10) > 0) then
       !! Store FIactual = Qk - FDk - FSk
       call DCOPY (sam%neq,sys%Qk(1),1,data(istat),1)
       call DAXPY (sam%neq,-1.0_dp,sys%FDk(1),1,data(istat),1)
       call DAXPY (sam%neq,-1.0_dp,sys%FSk(1),1,data(istat),1)
    else ! Store FIactual = FIk
       call DCOPY (sam%neq,sys%FIk(1),1,data(istat),1)
    end if
    istat = istat + sam%neq
    if (istat > ndat+1) then
       call reportError (error_p,'State array exhausted while saving '// &
            &            'System inertia vector')
    else
       !! Save previous step, time and time step size
       data(istat)   = real(sys%nStep-1_i8,dp)
       data(istat+1) = sys%time - sys%timeStep
       data(istat+2) = sys%timePrev
    end if

    istat = istat+2 - ndat ! Should be zero
    if (istat >= 0) return

915 call reportError (debugFileOnly_p,'saveToCore')

  end subroutine saveToCore


  !!============================================================================
  !> @brief Saves the transformation data of current step to an array in core.
  !>
  !> @param[in] sys System level model data
  !> @param[in] mech Mechanism components of the model
  !> @param[in] ndat Length of the solution state array
  !> @param[in] data Solution state array
  !> @param[out] istat Status flag, &lt;0: Error, =0: Ok,
  !> &gt;0: The @a data array is this value longer than necessary
  !>
  !> @details It also saves a TypeId and BaseId for triads and superelements.
  !> The TypeId is 1 for triads and 2 for superelements (FE-parts).
  !>
  !> @callergraph
  !>
  !> @author Runar Heggelien Refsnaes
  !>
  !> @date 28 Jun 2017

  subroutine saveTransformationDataToCore (sys, mech, data, ndat, istat)

    use SystemTypeModule   , only : SystemType, dp
    use MechanismTypeModule, only : MechanismType
    use progressModule     , only : writeProgress
    use reportErrorModule  , only : reportError, note_p, debugFileOnly_p

    type(SystemType)   , intent(in)  :: sys
    type(MechanismType), intent(in)  :: mech
    integer            , intent(in)  :: ndat
    real(dp)           , intent(out) :: data(ndat)
    integer            , intent(out) :: istat

    !! Local variables
    integer :: i, j, ndof

    !! --- Logic section ---

    if (ndat < 3) then
       istat = 0
       call reportError (note_p,'No state array provided, saving skipped')
       return
    end if

    call writeProgress (' --> Saving current position state to core')

    !! Save current step number, time and time step size
    data(1) = real(sys%nStep,dp)
    data(2) = sys%time
    data(3) = sys%timeStep
    istat = 4

    !! Save current triad data
    do i = 1, size(mech%triads)

       ndof = mech%triads(i)%nDOFs
       if (mech%triads(i)%id%baseId < 0) then
          cycle ! This is a center of gravity triad for a generic part
       else if (ndof == 6) then
          data(istat) = 1.0_dp ! TypeId
          data(istat+1) = real(mech%triads(i)%id%baseId,dp)
          do j = 1, 4
             data(istat+3*j-1:istat+3*j+1) = mech%triads(i)%ur(:,j)
          end do
          istat = istat + 14
       else if (ndof == 3) then
          data(istat) = 1.0_dp ! TypeId
          data(istat+1) = mech%triads(i)%id%baseId
          data(istat+3:istat+9) = 0.0_dp
          do j = 2, 10, 4
             data(istat+j) = 1.0_dp
          end do
          data(istat+11:istat+13) = mech%triads(i)%ur(:,4)
          istat = istat + 14
       else
          cycle
       end if

       if (outOfRange('save','Triad', mech%triads(i)%id,istat,ndat)) goto 99

    end do

    !! Save current superelement data
    do i = 1, size(mech%sups)

       data(istat) = 2.0_dp ! TypeId
       data(istat+1) = real(mech%sups(i)%id%baseId,dp)
       do j = 1, 4
          data(istat+3*j-1:istat+3*j+1) = mech%sups(i)%supTr(:,j)
       end do
       istat = istat + 14

       if (outOfRange('save','Superelement',mech%sups(i)%id,istat,ndat)) goto 99

    end do

    istat = istat - ndat ! Should be zero
    if (istat >= 0) return

99  call reportError (debugFileOnly_p,'saveTransformationDataToCore')

  end subroutine saveTransformationDataToCore


  !!============================================================================
  !> @brief Saves triad results to in-core array for restart.
  !>
  !> @param[in] triads All triads in the model
  !> @param[in] ndat Length of the solution state array
  !> @param[in] data Solution state array
  !> @param idat Running array index, negative value indicates an error
  !>
  !> @callergraph
  !>
  !> @author Knut Morten Okstad
  !>
  !> @date 16 Jan 2017

  subroutine saveTriadData (triads,data,ndat,idat)

    use TriadTypeModule, only : TriadType, dp

    type(TriadType), intent(in)    :: triads(:)
    integer        , intent(in)    :: ndat
    real(dp)       , intent(inout) :: data(ndat)
    integer        , intent(inout) :: idat

    !! Local variables
    integer :: i, j, ndof

    !! --- Logic section ---

    do i = 1, size(triads)

       ndof = triads(i)%nDOFs
       if (triads(i)%id%baseId < 0) then
          cycle ! This is a center of gravity triad for a generic part
       else if (ndof == 6) then
          do j = 1, 4
             data(idat+3*j-3:idat+3*j-1) = triads(i)%urPrev(:,j)
             data(idat+3*j+9:idat+3*j+11) = triads(i)%ur(:,j)
          end do
          idat = idat + 24
       else if (ndof == 3) then
          data(idat:idat+2) = triads(i)%urPrev(:,4)
          data(idat+3:idat+5) = triads(i)%ur(:,4)
          idat = idat + 6
       else
          cycle
       end if

       data(idat:idat+ndof-1) = triads(i)%urd; idat = idat + ndof
       data(idat:idat+ndof-1) = triads(i)%urdd; idat = idat + ndof
       if (associated(triads(i)%nodeForce)) then
          data(idat:idat+ndof-1) = triads(i)%nodeForce; idat = idat + ndof
       end if

       if (outOfRange('save','Triad',triads(i)%id,idat,ndat)) return

    end do

  end subroutine saveTriadData


  !!============================================================================
  !> @brief Saves superelement results to in-core array for restart.
  !>
  !> @param[in] sups All superelements in the model
  !> @param[in] ndat Length of the solution state array
  !> @param[in] data Solution state array
  !> @param idat Running array index, negative value indicates an error
  !>
  !> @callergraph
  !>
  !> @author Knut Morten Okstad
  !>
  !> @date 16 Jan 2017

  subroutine saveSuperelementData (sups,data,ndat,idat)

    use SupElTypeModule, only : SupElType, dp

    type(SupElType), intent(in)    :: sups(:)
    integer        , intent(in)    :: ndat
    real(dp)       , intent(inout) :: data(ndat)
    integer        , intent(inout) :: idat

    !! Local variables
    integer :: i, j, ndof

    !! --- Logic section ---

    do i = 1, size(sups)

       do j = 1, 4
          data(idat+3*j-3:idat+3*j-1) = sups(i)%supTrPrev(:,j)
          data(idat+3*j+9:idat+3*j+11) = sups(i)%supTr(:,j)
       end do
       idat = idat + 24

       if ( sups(i)%rigidFlag > 0 .and. &
            sups(i)%triads(1)%p%id%baseId < 0 .and. &
            sups(i)%triads(1)%p%nDOFs == 6 ) then

          !! This is a generic part with the CoG triad retained
          do j = 1, 4
             data(idat+3*j-3:idat+3*j-1)  = sups(i)%triads(1)%p%urPrev(:,j)
             data(idat+3*j+9:idat+3*j+11) = sups(i)%triads(1)%p%ur(:,j)
          end do
          data(idat+24:idat+29) = sups(i)%triads(1)%p%urd
          data(idat+30:idat+35) = sups(i)%triads(1)%p%urdd
          idat = idat + 36

       else if (associated(sups(i)%genDOFs)) then

          !! This is a flexible FE part with component modes
          ndof = size(sups(i)%genDOFs%ur)
          data(idat:idat+ndof-1) = sups(i)%genDOFs%urPrev; idat = idat + ndof
          data(idat:idat+ndof-1) = sups(i)%genDOFs%ur    ; idat = idat + ndof
          data(idat:idat+ndof-1) = sups(i)%genDOFs%urd   ; idat = idat + ndof
          data(idat:idat+ndof-1) = sups(i)%genDOFs%urdd  ; idat = idat + ndof

       end if

       if (outOfRange('save','Superelement',sups(i)%id,idat,ndat)) return

    end do

  end subroutine saveSuperelementData


  !!==========================================================================
  !> @brief Saves joint results to in-core state array for restart.
  !>
  !> @param[in] joints All joints in the model
  !> @param[in] ndat Length of the solution state array
  !> @param[in] data Solution state array
  !> @param idat Running array index, negative value indicates an error
  !>
  !> @callergraph
  !>
  !> @author Knut Morten Okstad
  !>
  !> @date 16 Jan 2017

  subroutine saveJointData (joints,data,ndat,idat)

    use MasterSlaveJointTypeModule, only : MasterSlaveJointType, dp
    use rotationModule            , only : vec_to_mat

    type(MasterSlaveJointType), intent(in)    :: joints(:)
    integer                   , intent(in)    :: ndat
    real(dp)                  , intent(inout) :: data(ndat)
    integer                   , intent(inout) :: idat

    !! Local variables
    integer :: i, j

    !! --- Logic section ---

    do i = 1, size(joints)
       do j = 1, size(joints(i)%jointDofs)
          if (joints(i)%jointDofs(j)%fixed) cycle

          call saveJDof (joints(i)%jointDofs(j),idat)
          if (outOfRange('save','Joint',joints(i)%id,idat,ndat)) return

       end do
    end do

  contains

    !> @brief Saves joint DOF results to the in-core state array.
    subroutine saveJDof (jDof,idat)
      use MasterSlaveJointTypeModule, only : JointDofType
      type(JointDofType), intent(in)    :: jDof
      integer           , intent(inout) :: idat
      data(idat) = jDof%jVarPrev
      data(idat+1:idat+3) = jDof%jVar
      idat = idat + 4
      if (associated(jDof%friction)) then
         data(idat) = jDof%friction%pos
         data(idat+1) = jDof%friction%lSlip(1)*10 + jDof%friction%lSlip(2)
         idat = idat + 2
      end if
    end subroutine saveJDof

  end subroutine saveJointData


  !!============================================================================
  !> @brief Saves damper results to in-core state array for restart.
  !>
  !> @param[in] dampers All damper elements in the model
  !> @param[in] ndat Length of the solution state array
  !> @param[in] data Solution state array
  !> @param idat Running array index, negative value indicates an error
  !>
  !> @details Only the damper velocity needs to be stored, if the damper uses
  !> deformational velocity. Because it is computed using the previous spring
  !> deflection which is not known at restart point.
  !>
  !> @callergraph
  !>
  !> @author Knut Morten Okstad
  !>
  !> @date 1 Jul 2022

  subroutine saveDamperData (dampers,data,ndat,idat)

    use DamperTypeModule, only : DamperType, dp

    type(DamperType), intent(in)    :: dampers(:)
    integer         , intent(in)    :: ndat
    real(dp)        , intent(inout) :: data(ndat)
    integer         , intent(inout) :: idat

    !! Local variables
    integer :: i

    !! --- Logic section ---

    do i = 1, size(dampers)
       if (associated(dampers(i)%dmp%spr)) then

          data(idat) = dampers(i)%dmp%velocity
          idat = idat + 1

          if (outOfRange('save','Damper',dampers(i)%dmp%id,idat,ndat)) return

       end if
    end do

  end subroutine saveDamperData


  !!============================================================================
  !> @brief Saves contact element results to in-core state array for restart.
  !>
  !> @param[in] cElems All contact elements in the model
  !> @param[in] ndat Length of the solution state array
  !> @param[in] data Solution state array
  !> @param idat Running array index, negative value indicates an error
  !>
  !> @callergraph
  !>
  !> @author Knut Morten Okstad
  !>
  !> @date 16 Jan 2017

  subroutine saveContactElementData (cElems,data,ndat,idat)

    use ContactElementTypeModule, only : ContactElementType, dp

    type(ContactElementType), intent(in)    :: cElems(:)
    integer                 , intent(in)    :: ndat
    real(dp)                , intent(inout) :: data(ndat)
    integer                 , intent(inout) :: idat

    !! Local variables
    integer :: i

    !! --- Logic section ---

    do i = 1, size(cElems)

       data(idat:idat+2) = cElems(i)%cVarPrev
       data(idat+3) = cElems(i)%accContactDist
       idat = idat + 4

       if (outOfRange('save','Contactelement',cElems(i)%id,idat,ndat)) return

    end do

  end subroutine saveContactElementData


  !!============================================================================
  !> @brief Saves prescribed motion results to in-core state array for restart.
  !>
  !> @param[in] motions All prescribed motions in the model
  !> @param[in] ndat Length of the solution state array
  !> @param[in] data Solution state array
  !> @param idat Running array index, negative value indicates an error
  !>
  !> @callergraph
  !>
  !> @author Knut Morten Okstad
  !>
  !> @date 13 Jan 2017

  subroutine saveMotionData (motions,data,ndat,idat)

    use MotionTypeModule, only : MotionType, dp

    type(MotionType), intent(in)    :: motions(:)
    integer         , intent(in)    :: ndat
    real(dp)        , intent(inout) :: data(ndat)
    integer         , intent(inout) :: idat

    !! Local variables
    integer :: i

    !! --- Logic section ---

    do i = 1, size(motions)

       data(idat)   = motions(i)%D
       data(idat+1) = motions(i)%cc
       idat = idat + 2

       if (outOfRange('save','Motion',motions(i)%id,idat,ndat)) return

    end do

  end subroutine saveMotionData


  !!============================================================================
  !> @brief Saves control system data to in-core state array for restart.
  !>
  !> @param[in] ctrl Control system data
  !> @param[in] ndat Length of the solution state array
  !> @param[in] data Solution state array
  !> @param idat Running array index, negative value indicates an error
  !>
  !> @callergraph
  !>
  !> @author Knut Morten Okstad
  !>
  !> @date 22 Dec 2020

  subroutine saveControlData (ctrl,data,ndat,idat)

    use KindModule       , only : dp
    use ControlTypeModule, only : ControlType
    use reportErrorModule, only : reportError, error_p

    type(ControlType), intent(in)    :: ctrl
    integer          , intent(in)    :: ndat
    real(dp)         , intent(inout) :: data(ndat)
    integer          , intent(inout) :: idat

    !! Local variables
    integer :: ip, nw

    !! --- Logic section ---

    nw = size(ctrl%vreg)
    call DCOPY (nw,ctrl%vreg(1),1,data(idat),1)
    idat = idat + nw

    !! Save integer control array ICNT
    do ip = ctrl%mpireg(1), ctrl%mpireg(2)-1
       data(idat) = real(ctrl%ireg(ip),dp)
       idat = idat + 1
    end do

    call saveRREG (1) ! Save real control array RCNT
    call saveRREG (2) ! Save real control array VPREG
    call saveRREG (6) ! Save real control array VHREG

    if (associated(ctrl%delay)) then
       nw = ctrl%ireg(10) ! Save DELAY buffer
       call DCOPY (nw,ctrl%delay(1),1,data(idat),1)
       idat = idat + nw
    end if

    if (idat <= ndat+1) return

    idat = ndat+1 - idat
    call reportError (error_p,'State array exhausted while saving '// &
         &            'control system data',addString='saveControlData')

  contains

    !> @brief Saves a real control array to the state array.
    subroutine saveRREG (i)
      integer, intent(in) :: i
      ip = ctrl%mprreg(i)
      nw = ctrl%mprreg(i+1) - ip
      call DCOPY (nw,ctrl%rreg(ip),1,data(idat),1)
      idat = idat + nw
    end subroutine saveRREG

  end subroutine saveControlData


  !!============================================================================
  !> @brief Prints an error message when the in-core state array is exhausted.
  !>
  !> @callergraph
  !>
  !> @author Knut Morten Okstad
  !>
  !> @date 13 Jan 2017

  function outOfRange (oper,object,id,idat,ndat)

    use IdTypeModule     , only : IdType, getId
    use reportErrorModule, only : reportError, error_p

    character(len=*), intent(in)    :: oper,object
    type(IdType)    , intent(in)    :: id
    integer         , intent(inout) :: idat
    integer         , intent(in)    :: ndat

    !! Local variables
    logical :: outOfRange

    !! --- Logic section ---

    outOfRange = idat > ndat+1
    if (.not. outOfRange) return

    idat = ndat+1 - idat
    call reportError (error_p,'State array exhausted while loading '// &
         &            'time step data for '//object//getId(id), &
         &            addString=oper//object//'Data')

  end function outOfRange

end module restartModule
